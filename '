/*
 *
 *  * Copyright (c) 2024 Govcraft.
 *  *
 *  * Licensed under the Apache License, Version 2.0 (the "License");
 *  * you may not use this file except in compliance with the License.
 *  * You may obtain a copy of the License at
 *  *
 *  *     http://www.apache.org/licenses/LICENSE-2.0
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  * See the License for the specific language governing permissions and
 *  * limitations under the License.
 *
 *
 */

use crate::common::actor::ActorPoolDef;
use crate::common::*;
use crate::common::{Idle, InboundChannel, LifecycleReactor, StopSignal};
use crate::prelude::{ActorContext, ConfigurableActor, LoadBalancerStrategy, SupervisorContext};
use crate::traits::QuasarMessage;
use dashmap::mapref::one::Ref;
use dashmap::DashMap;
use quasar_qrn::Qrn;
use std::any::TypeId;
use std::collections::HashMap;
use std::env;
use std::fmt::Debug;
use std::future::Future;
use std::marker::PhantomData;
use std::pin::Pin;
use std::sync::atomic::Ordering;
use std::time::Duration;
use tokio::sync::mpsc::{channel, Receiver, Sender};
use tokio_util::context;
use tokio_util::task::TaskTracker;
use tracing::field::debug;
use tracing::{debug, instrument, trace, warn};

#[derive(Debug)]
pub(crate) struct PoolDef<T: ConfigurableActor + Debug + Send + 'static> {
    pub(crate) size: usize,
    pub(crate) actor_type: T,
    pub(crate) strategy: LBStrategy,
}

#[derive(Debug)]
pub struct PoolBuilder<
    T: ConfigurableActor + Debug + Send + 'static,
    S: LoadBalancerStrategy + Default,
> {
    pools: HashMap<String, PoolDef<T>>,
    lbs: S,
}
impl<T: ConfigurableActor + Debug + Send + 'static, S: LoadBalancerStrategy + Default>
    PoolBuilder<T, S>
{
    pub fn new() -> PoolBuilder<T, S> {
        PoolBuilder {
            pools: HashMap::new(),
            lbs: S::default(),
        }
    }
    pub fn add_pool(mut self, name: String, size: usize, strategy: LBStrategy) -> Self {
        let pool = T::new();
        let def = PoolDef {
            size,
            actor_type: pool,
            strategy,
        };
        self.pools.insert(name, def);
        self
    }
    pub(crate) async fn spawn(mut self, parent: &Context) -> Supervisor {
        let subordinates = DashMap::new();
        for (pool_name, pool_def) in &self.pools {
            let pool_name = pool_name.to_string();
            let mut context_items = Vec::with_capacity(pool_def.size);
            for _i in 0..pool_def.size {
                let context = pool_def.actor_type.init(pool_name.clone(), parent).await;
                context_items.push(context);
            }
            let item = PoolItem {
                id: pool_name.clone(),
                pool: context_items,
            };
            subordinates.insert(pool_name, item);
        }
        let (outbox, mailbox) = channel(255);
        let task_tracker = TaskTracker::new();
        tracing::trace!("{:?}", subordinates);
        Supervisor {
            key: parent.key.clone(),
            halt_signal: StopSignal::new(false),
            subordinates,
            outbox,
            mailbox,
            task_tracker,
        }
    }
}
pub(crate) struct Supervisor {
    pub(crate) key: Qrn,
    pub(crate) halt_signal: StopSignal,
    pub(crate) subordinates: DashMap<String, PoolItem>,
    pub(crate) task_tracker: TaskTracker,
    pub(crate) outbox: Sender<Envelope>,
    pub(crate) mailbox: Receiver<Envelope>,
}
impl Debug for Supervisor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.key.value)
    }
}

#[derive(Debug)]
pub(crate) struct PoolItem {
    id: String,
    pool: Vec<Context>,
    strategy: LBStrategy,
}

impl Supervisor {
    #[instrument(skip(self))]
    pub(crate) async fn wake_supervisor(&mut self) {
        loop {
            if let Ok(envelope) = self.mailbox.try_recv() {
                if let Some(ref pool_id) = envelope.pool_id {
                    tracing::trace!("{:?}", self.subordinates);
                    if let Some(pool_def) = self.subordinates.get(pool_id) {
                        let context = &pool_def.pool[0];
                        context.emit_envelope(envelope).await;
                    }
                } else if let Some(concrete_msg) =
                    envelope.message.as_any().downcast_ref::<SystemSignal>()
                {
                    match concrete_msg {
                        SystemSignal::Wake => {}
                        SystemSignal::Recreate => {}
                        SystemSignal::Suspend => {}
                        SystemSignal::Resume => {}
                        SystemSignal::Terminate => {
                            self.terminate().await;
                        }
                        SystemSignal::Supervise => {}
                        SystemSignal::Watch => {}
                        SystemSignal::Unwatch => {}
                        SystemSignal::Failed => {}
                    }
                } // Checking stop condition .
            }
            let should_stop =
                { self.halt_signal.load(Ordering::SeqCst) && self.mailbox.is_empty() };

            if should_stop {
                break;
            } else {
                tokio::time::sleep(Duration::from_nanos(1)).await;
            }
        }
    }
    #[instrument(skip(self))]
    pub(crate) async fn terminate(&self) {
        let subordinates = &self.subordinates;
        tracing::trace!("subordinate count: {}", subordinates.len());
        let halt_signal = self.halt_signal.load(Ordering::SeqCst);
        if !halt_signal {
            for item in subordinates {
                for context in &item.value().pool {
                    let envelope = &context.return_address();
                    //                    tracing::warn!("Terminating {}", &context.key.value);
                    tracing::trace!("Terminating done {:?}", &context);
                    //                        if let Some(envelope) = supervisor {
                    envelope.reply(SystemSignal::Terminate, None);
                    //                       }
                    //context.terminate_subordinates().await;
                    context.terminate_actor().await;
                }
            }
            self.halt_signal.store(true, Ordering::SeqCst);
        }
    }
}
